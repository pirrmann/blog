---
layout: post
title: "More colors in the terminal"
tags: F#, Terminal, XTerm
---

After releasing [ColoredPrintf][coloredprintf] I started investigating color terminals, especially how some
terminals can display more than the traditional 16 colors.

While on windows console colors are changed using a call to the
[`SetConsoleTextAttribute`][msdn_consoletextattr] API, on unix XTerm and other terminals follow the way the VT100
physical terminal did it with special [escape sequences][wikipedia] that are sent to the terminal but change it's
behavior instead of being displayed.

It is especially interesting as such terminals are becomming more present, even in the windows world. The
excelent [ConEmu][conemu] support lot of the codes, the venerable `cmd.exe` can be told to interpret them (as we'll
see later) and it'll even soon [gain True Color support too][windows10truecolor].

Compatibility
-------------

* On windows running [ConEmu][conemu] is the best you can do, there is a little trick to enable more than 16 colors
  but it's easy and need to be done only once per session. I'll explain how to do it from code in in
  [a dedicated paragraph](#conemu) but you can simply display one of the ConEmu sample file with
  `cmd /c type "%ConEmuBaseDir%\Addons\AnsiColors256.ans"` and it'll activate it.
* On macOS (Tested on sierra) the integrated terminal can display 256 colors without problems but will translate
  any True Color command to 16 colors, giving a very ugly result. But [iTerm2][iterm2] is free and seem to support
  everything I could send to it flawlessly.
* I didn't do any test on linux but most of these codes are xterm extensions so in case of problems, revert to xterm.
* [Visual Studio Code][vscode] integrated terminal can do most of them and as the REPL provided by the
  [Ionide plugin][ionide] uses it we can use the F# REPL directly there. But **beware** the windows version of the
  VSCode terminal is pretty buggy at the moment and often completely break when control codes are sent.

Using F# to play with escape sequences
--------------------------------------

Escape sequences are generated by printing the **`ESC`** (`0x1B)` character followed by at least another character.

The most common ones start with the "CSI" sequence `ESC[` followed by parameters and ending with a character
designating the command. The full list is on [Wikipedia][wikipedia] or [MSDN][msdn_vt100].

Let's try that in F# :

```fsharp
let esc = string (char 0x1B)
System.Console.WriteLine(esc + "[31;1m" + "Hello world" + esc + "[0m")
```

![First sample](/assets/color-terminal-first-sample.png)

It displayed `Hello World` in bright red as `m` is the graphic command taking sub-commands separated by `;`,
`31` is the red color and `1` signal that we want bold/bright text. And at the end `0` is the reset sub-command,
without it the terminal would stay red on all following lines.

Using `kprintf` we can create a printf-like function and start implementing a few of the escape sequences :

```fsharp
let csi = esc + "["
let printsequencef f = Printf.kprintf (fun s -> System.Console.Write(esc + s)) f
let printcsif f = Printf.kprintf (fun s -> System.Console.Write(csi + s)) f
let selectGraphicRendition (gr: int list) =
    printcsif "%sm" (System.String.Join(";", gr |> Seq.map string))
let resetColor() = selectGraphicRendition [0]
let setForeground i = selectGraphicRendition([30 + i])
let setBackground i = selectGraphicRendition([40 + i])
```

256 colors is enough for everyone
---------------------------------

Until then we've done nothing very interesting, after all the .Net console already support changing the console
color to bright red, nothing new under the sun. But what the .Net console or Windows native API doesn't support
is the `38` and `48` graphics sub-commands, extended foreground an background colors.

```fsharp
let setExtendedForeground i = selectGraphicRendition [38; 5; i]
let setExtendedBackground i = selectGraphicRendition [48; 5; i]
let setForegroundRgb r g b = selectGraphicRendition [38; 2; r; g; b]
let setBackgroundRgb r g b = selectGraphicRendition [48; 2; r; g; b]
```

The first variant accept an index in a 256 colors table and the second specify the R, G and B components.

While all the terminal emulators I tested support both of them the colors the display will vary, especially for
the R;G;B True Color mode. Some like macOS default terminal are pretty weird in the sense that it support 256 color
mode but interpolate any R;G;B code to 16 colors.

Let's see what the palete looks like :

```fsharp
let extendedBlock i =
    for j in i..i+5 do
        setExtendedBackground j
        printf "  "

for row in 0..5 do
    for b in 0..5 do
        extendedBlock (16 + 36*b + row*6)
        resetColor()
        printf " "
    printfn ""
```

The result in VS Code (On macOS) :

![Palete](/assets/color-terminal-256-pal.png)

We need to be true to our colors
--------------------------------

Now that we know how to draw with true colors we can draw pictures on the terminal :

```fsharp
open System.Drawing

let showBitmap path =
    let bitmap = Image.FromFile(path) :?> Bitmap
    for y in 0..bitmap.Size.Height-1 do
        for x in 0..bitmap.Size.Width-1 do
            let px = bitmap.GetPixel(x, y)
            setBackgroundRgb (int px.R) (int px.G) (int px.B)
            printf "  "
        resetColor()
        printfn ""
```

And we can apply it to a 40x40px version of the FSharp logo :

![Logo](/assets/color-terminal-logo.png)

The code for all of that can be found in [a Gist][gist].

Appendix A: ConEmu color support<a name="conemu"></a>
---------------------------------------------------

ConEmu support more than the standard 16 colors but if you try it, it won't work directly, it seem that maybe for
compatibility reasons the support isn't always on.

![Before](/assets/color-terminal-conemu-16.png)

To trigger it an application must first scroll the terminal far away at least once with the `T` command :

```fsharp
let scrollUp (lines: int) = printcsif "%iS" lines
let scrollDown (lines: int) = printcsif "%iT" lines
scrollDown 9999
setCursorPos 9999 1
```

After that ConEnu will display what we expect :

![After](/assets/color-terminal-conemu-256.png)

Appendix B: Enabling escape codes in `cmd.exe`
----------------------------------------------

While the windows terminal support escape codes, it doesn't do it directly. They need
to be enabled using `SetConsoleMode` API :

```fsharp
#nowarn "9"
module DllImports =
    open System.Runtime.InteropServices
    open Microsoft.FSharp.NativeInterop

    let INVALID_HANDLE_VALUE = nativeint -1
    let STD_OUTPUT_HANDLE = -11
    let ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004

    [<DllImport("Kernel32")>]
    extern void* GetStdHandle(int nStdHandle)

    [<DllImport("Kernel32")>]
    extern bool GetConsoleMode(void* hConsoleHandle, int* lpMode)

    [<DllImport("Kernel32")>]
    extern bool SetConsoleMode(void* hConsoleHandle, int lpMode)

    let enableVTMode() =
        let handle = GetStdHandle(STD_OUTPUT_HANDLE)
        if handle <> INVALID_HANDLE_VALUE then
            let mode = NativePtr.stackalloc<int> 1
            if GetConsoleMode(handle, mode) then
                let value = NativePtr.read mode
                let value = value ||| ENABLE_VIRTUAL_TERMINAL_PROCESSING
                SetConsoleMode(handle, value)
            else
                printfn "no get"
                false
        else
            printfn "no handle"
            false

DllImports.enableVTMode() |> ignore
```


[ionide]: http://ionide.io/
[vscode]: https://code.visualstudio.com/
[conemu]: https://conemu.github.io/
[coloredprintf]: https://github.com/vbfox/ColoredPrintf
[wikipedia]: https://en.wikipedia.org/wiki/ANSI_escape_code
[msdn_vt100]: https://msdn.microsoft.com/en-us/library/windows/desktop/mt638032(v=vs.85).aspx
[msdn_consoletextattr]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms686047(v=vs.85).aspx
[windows10truecolor]: https://blogs.msdn.microsoft.com/commandline/2016/09/22/24-bit-color-in-the-windows-console/
[iterm2]: https://www.iterm2.com/
[gist]: https://gist.github.com/vbfox/f8857242d6b0ce0e4de1e02e2d3f15a0